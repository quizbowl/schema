scalar Date

type Query {
  tournaments: [Tournament]
}

"""
A `Tournament` object describes a tournament for which a single result is published. A `Tournament` consists of a number of `Match` objects, a number of `Registration` objects, and other optional information.

Docs group: Tournament
"""
type Tournament {
  id: ID!

  """
  The tournament's name.
  """
  name: String!

  """
  An abbreviated version of the tournament's `name`. If omitted, assume the same as the `name`.
  """
  short_name: String

  """
  Where this tournament happened.
  """
  tournament_site: TournamentSite

  """
  Validation rules for scoring matches in this tournament.
  """
  scoring_rules: ScoringRules

  """
  The tournament's start date, including time zone, as an ISO 8601-formatted string in the tournament's local time zone.
  """
  start_date: Date

  """
  The tournament's end date, including time zone, as an ISO 8601-formatted string in the tournament's local time zone.
  """
  end_date: Date

  """
  The organizations registered to play in this tournament.
  """
  registrations: [Registration]

  """
  The phases of play in this tournament.
  """
  phases: [Phase]

  """
  The rankings used at this tournament.
  """
  rankings: [Ranking]

  """
  The intended audience of the tournament.
  """
  audience: TournamentAudience

  """
  The level of the tournament, within the context of its `audience`.
  """
  level: TournamentLevel

  """
  Free-form string of question set(s) used at this tournament.
  """
  question_set: String

  """
  The subject matter of the tournament question set(s).
  """
  content: TournamentContent

  """
  Free-form string of other information relevant to tournament.
  """
  info: String
}

enum TournamentAudience {
  elementary_school
  middle_school
  high_school
  community_college
  college
  open
  other
}

enum TournamentLevel {
  novice
  regular
  nationals
  other
}

enum TournamentContent {
  general_academic
  specialized_academic
  trash
  other
}

"""
A `Phase` object describes a part of the tournament with a unified match structure. A typical tournament might have one phase for the preliminary rounds and a second phase for the playoff rounds.

Docs group: Phase
"""
type Phase {
  id: ID!

  """
  The name of the phase, such as "Preliminary Rounds" or "Playoffs".
  """
  name: String!

  """
  A description of the phase. Might contain information like how teams are split into pools, the use of power-matching or elimination-based formats, etc.
  """
  description: String

  """
  The rounds within this phase.
  """
  rounds: [Round]

  """
  Whether teams may trade cards during this phase. For example, `true` would be used for a power-matching or elimination structure, while `false` could be used for a round-robin structure. If absent, assumed to be `false`.
  """
  cards_traded: Boolean

  """
  The pools (or similar structures) into which teams are placed for this phase.
  """
  pools: [Pool]
}

"""
Docs group: Phase
"""
type Round {
  id: ID!

  """
  The name of the round. Possibly numerical; possibly something like "Preliminary Tiebreaker".
  """
  name: String!

  """
  A description of the round. Probably unnecessary, but useful for "special" rounds like tiebreakers.
  """
  description: String

  """
  Information on what packet(s) were used in this round. If multiple packets were used for regular play, the order of this array should be the order in which they were used. If this is omitted and the `question_set` specified in the `Tournament` object has a packet that logically matches this round's `name` (e.g. "Round 1" and "Packet 1"), it can be assumed that the matching packet was used (and no other packets were used).
  """
  packets: [Packet]

  """
  The matches that took place in this round.
  """
  matches: [Match]
}

"""
A `Pool` object represents a set of teams that, in some meaningful sense, play together for the phase. They might be round-robin pools, playoff tiers, etc. It is not required that teams _only_ play matches within their pool.

Docs group: Phase
"""
type Pool {
  id: ID!

  """
  The name of the pool.
  """
  name: String!

  """
  A description of the pool.
  """
  description: String

  """
  The position/rank of this Pool among all Pool objects used for its Phase. Need not be unique (e.g. in the case of parallel pools).
  """
  position: Int

  """
  The assignments of teams to pools for this phase.
  """
  pool_teams: [PoolTeam]
}

"""
Docs group: Phase
"""
type PoolTeam {
  """
  The Pool to which the Team is assigned.
  """
  pool: Pool!

  """
  The Team being assigned to the Pool.
  """
  team: Team!

  """
  The final position/rank of this Team within this Pool.
  """
  position: Int
}

"""
Docs group: Tournament
"""
type ScoringRules {
  id: ID!

  """
  The name for this set of scoring rules.
  """
  name: String!

  """
  The number of teams that participates in each match. If omitted, assume `2`.
  """
  teams_per_match: Int

  """
  The maximum number of players that may be active at once, per team, in a match. If omitted, assume `4`.
  """
  maximum_players_per_team: Int

  """
  The standard number of tossups heard in a match. If omitted, assume `20`.
  """
  regulation_tossup_count: Int

  """
  The maximum number of tossups heard in a match that does not go into overtime. (Different from `regulation_tossup_count` for tournaments that used timed matches.) If omitted, assume `20`.
  """
  maximum_regulation_tossup_count: Int

  """
  The smallest possible number of overtime tossups or tossup-bonus cycles (as determined by `overtime_includes_bonuses`). If overtime is sudden death from the beginning, this will be `1`, and that is the value assumed if this field is omitted.
  """
  minimum_overtime_question_count: Int

  """
  Are bonuses used in overtime? If omitted, assume `false`.
  """
  overtime_includes_bonuses: Boolean

  """
  The largest integer that is guaranteed to be a factor of a valid final score for one team in one match. If omitted, assume `5`. If present, must be a positive integer.
  """
  total_divisor: Int

  """
  The maximum possible score on a single bonus. Omitting this means there are no bonuses. If present and `bonus_divisor` is present, must be divisible by `bonus_divisor`.
  """
  maximum_bonus_score: Int

  """
  The largest integer that is guaranteed to be a factor of a valid score on a single bonus. If omitted but `maximum_bonus_score` is present, assume `10`. If present, must be a positive integer.
  """
  bonus_divisor: Int

  """
  The smallest number of parts that may exist in one bonus. If omitted but `maximum_bonus_score` is present, assume `3`. If present, this must be a positive integer. If `maximum_parts_per_bonus` is present, this must be less than or equal to `maximum_parts_per_bonus`.
  """
  minimum_parts_per_bonus: Int

  """
  The greatest number of parts that may exist in one bonus. If omitted but `maximum_bonus_score` is present, assume `3`. If present, this must be a positive integer. If `minimum_parts_per_bonus` is present, this must be greater than or equal to `minimum_parts_per_bonus`.
  """
  maximum_parts_per_bonus: Int

  """
  The number of points earned for a correct answer to one bonus part. Omitting this while specifying `maximum_bonus_score` means that the number of points needn't be the same for all bonus parts. If present, this must be a positive integer. If `bonus_divisor` and this are both present, they must be consistent.
  """
  points_per_bonus_part: Int

  """
  `true` if the non-controlling team has an opportunity to answer parts of a bonus that the controlling team did not answer correctly; `false` if not. If omitted but `maximum_bonus_score` is present, assume `false`.
  """
  bonuses_bounce_back: Boolean

  """
  The number of lightning rounds received by each team in each game. If omitted, assume `0`.
  """
  lightning_count_per_team: Int

  """
  The maximum possible score on a single lightning round. If omitted but `lightning_count_per_team` is present and positive, assume `100`.
  """
  maximum_lightning_score: Int

  """
  The largest integer that is guaranteed to be a factor of a valid score on a single lightning round. If omitted but `lightning_count_per_team` is present and positive, assume `10`. If present, must be a positive integer.
  """
  lightning_divisor: Int

  """
  `true` if the non-controlling team has an opportunity to answer parts of a lightning round that the controlling team did not answer correctly; `false` if not. If omitted but `lightning_count_per_team` is present and positive, assume `true`.
  """
  lightnings_bounce_back: Boolean

  """
  The different answer types possible in this tournament.
  """
  answer_types: [AnswerType]!
}

"""
An `AnswerType` object has details about how tossups can be answered. If you’re talking about the traditional -5/10/15 answer types or some subset thereof, you can skip this and use the `value` field instead.

Docs group: Tournament
"""
type AnswerType {
  id: ID!

  """
  The number of points a player receives for this answer type.
  """
  value: Int!

  """
  How to label this answer type on reports. If omitted, turn the `value` into a string.
  """
  label: String

  """
  How to label this answer type on reports when space is limited, perhaps in a table column header. If omitted, use the `label` field.
  """
  short_label: String

  """
  Whether or not the team that gets this answer value will next receive a bonus question. If omitted, assume `true` if `value` is greater than zero and false otherwise.
  """
  awards_bonus: Boolean
}

"""
Docs group: Tournament
"""
type TournamentSite {
  id: ID!

  """
  The tournament site's name (e.g. "Hyatt Regency O'Hare").
  """
  name: String!

  """
  The location of the tournament. Free-form; the purpose is to enable people to find the site. An example might be "9300 Bryn Mawr Avenue, Rosemont, Illinois".
  """
  place: String

  """
  The latitude of the tournament's site (for geolocation).
  """
  latitude: Float

  """
  The longitude of the tournament's site (for geolocation).
  """
  longitude: Float
}

"""
A `Match` object describes a single match scheduled between two teams. A `Match` object with `MatchTeam` objects but without `MatchPlayer` objects can be used to describe a match that has been scheduled but not played. Matches are contained in `Round` objects, which are contained in `Phase` objects of the `Tournament`.

If a `Match` includes `Lineup` objects on its `MatchTeam` objects and includes `MatchQuestion` objects, a complete scoresheet can be reconstructed.

Docs group: Match
"""
type Match {
  id: ID!

  """
  The number of tossups read, *including* any tossups read in overtime. This should be absent or null (not `0`) in forfeit matches.
  """
  tossups_read: Int

  """
  The number of tossups read in overtime. This should be absent or null (not `0`) in forfeit matches.
  """
  overtime_tossups_read: Int

  """
  The location of the match. Probably a room name.
  """
  location: String

  """
  The packet(s) used for the match *if* different from that implied by the `packet` field of the `Round` containing the match. This would be used if a small number of matches used different packet(s) than most matches in that round, e.g. by mistake, to fix a previous mistake, or to accommodate a team that had written the packet used for most games in the round.
  """
  packets: String

  """
  Was the match a tiebreaker match?
  """
  tiebreaker: Boolean

  """
  Moderator's name.
  """
  moderator: String

  """
  Scorekeeper's name.
  """
  scorekeeper: String

  """
  "For control room use only"-type serial number.
  """
  serial: String

  """
  The performances of the teams in this match; see below.
  """
  match_teams: [MatchTeam]!

  """
  Additional phases in which this match should count, besides the one that actually contains it. This is used for "carrying over" games.
  """
  carryover_phases: [Phase]

  """
  The question-by-question account of what happened.
  """
  match_questions: [MatchQuestion]

  """
  Freeform text field to record any notes about the match, such as protests or questions read out of order.
  """
  notes: String
}

"""
Docs group: Question
"""
type Packet {
  """
  A human-readable identifier. Often primarily numeric (e.g., `Packet 1`), but could also be identified by authors (`Chicago` or `Yale + Maryland`), as for packet-submission tournaments.
  """
  name: String!
  
  """
  The packet number, if that notion is meaningful. May also be contained in the `name`, but need not be, e.g. if both `number` and `authors` are specified, the `name` will typically only contain one of them (whichever is more important).
  """
  number: Int
  
  """
  The authors of the packet. May also be contained in the `name`, but need not be, e.g. if both `number` and `authors` are specified, the `name` will typically only contain one of them (whichever is more important).
  """
  authors: [String]

  """
  How the packet is expected to be used. An `extra` packet typically consists only of tossups, and is for use in overtime and/or as replacements, as necessary. Note that a packet might be used differently in case of unusual situations.
  """
  role: PacketRole

  """
  Any further details on the packet.
  """
  notes: String

  """
  The contents of the packet, in order.
  """
  questions: [Question]
}

enum PacketRole {
  regular
  finals
  extra
  overtime
  replacement
  backup
  tiebreaker
  scrimmage
}

"""
Docs group: Question
"""
type MatchQuestion {
  """
  Which tossup-bonus cycle number this was. Starts at 1.
  """
  question_number: Int!

  """
  Information about the tossup question in this cycle.
  """
  tossup_question: Question

  """
  The time at which the moderator began reading the tossup. An ISO 8601-formatted string, with time zone, in the tournament's local time zone.
  """
  tossup_start_time: Date

  """
  Information about the tossup question used as a replacement in this cycle, if any. Omit if the tossup was not replaced. Multiple replacement tossups are not currently supported.
  """
  replacement_tossup_question: Question

  """
  The time at which the moderator began reading the replacement tossup. An ISO 8601-formatted string, with time zone, in the tournament's local time zone.
  """
  replacement_tossup_start_time: Date

  """
  The `MatchTeam`s who were eligible to answer the replacement tossup. Any `MatchTeam`s in this match but not in this field should be understood to have been eligible to answer the original `tossup_question`.
  """
  replacement_tossup_question_match_teams: [MatchTeam]

  """
  The number of points scored and by whom on each buzz. The length of this array will be equal to or less than the number of teams playing the match.
  """
  buzzes: [MatchQuestionBuzz]!

  """
  How many bonus points were awarded on this question. May be omitted if the question type doesn't award a bonus; must be omitted if `bonus` is present.
  """
  bonus_points: Int

  """
  How many bonus points were awarded when this question's bonus bounced back. May be omitted if `bonus` is present, if the question type doesn't award a bonus, or if bonuses don't bounce back.
  """
  bonus_bounceback_points: Int

  """
  Information about the bonus that was read for this question. Must be omitted if `bonus_points` is present; may be omitted if no bonus was read for this question, but should not be omitted merely because no points were earned on the bonus.
  """
  bonus: MatchQuestionBonus

  """
  The time at which the moderator began reading the bonus. An ISO 8601-formatted string, with time zone, in the tournament's local time zone.
  """
  bonus_start_time: Date

  """
  Information about the bonus question used as a replacement in this cycle, if any. Omit if the bonus was not replaced. Multiple replacement bonuses are not currently supported.
  """
  replacement_bonus: MatchQuestionBonus
}

"""
Docs group: Question
"""
type MatchQuestionBuzz {
  """
  Which team's player buzzed in.
  """
  team: Team!

  """
  Which player buzzed in.
  """
  player: Player!

  """
  Details on the timing of the buzz.
  """
  buzz_position: BuzzPosition

  """
  The result of the player's buzz, representing how many points the player's team received.
  """
  result: AnswerType!
}

"""
Docs group: Question
"""
type BuzzPosition {
  """
  The time of the buzz. An ISO 8601-formatted string, with time zone, in the tournament's local time zone. May not be before the start time of reading the relevant question.
  """
  time: Date

  """
  The (`0`-based) index of the word on which the player buzzed. Hearing any part of a word should be considered the same as hearing the entire word. So if a question begins "Abraham Lincoln…" and the player buzzes on "Abra—", this value would be `0`.
  """
  word_index: Int

  """
  The (`0`-based) index of the clue on which the player buzzed. Clues may be defined in the `Question` object. Hearing any part of a clue should be considered the same as hearing the entire clue.
  """
  clue_index: Int
}

"""
This object can be reused for every time the same question is read, i.e., it represents a question in general rather than a question being read in a specific match.

Docs group: Question
"""
type Question {
  """
  The number of the question in the packet.
  """
  question_number: Int!
  
  """
  The type of the question.
  """
  type: QuestionType!
  
  """
  The number of parts the question has (typically `1` if `type` is `tossup` and `3` if `type` is `bonus`, but some formats may vary).
  """
  parts: Int
  
  """
  The identifier for the question in some external system, if any (e.g., the question IDs that NAQT prints below each question in its packet).
  """
  external_id: String
  
  """
  Freeform information about the question's category, e.g. `British History`.
  """
  category: String
  
  """
  Freeform information about the question's category at a higher level of aggregation, e.g. `History`.
  """
  category_group: String
  
  """
  The text of the question (as a single field).
  """
  text: String
  
  """
  The text of the question, broken up into clues so that `BuzzPosition`s can reference which clue was being buzzed on. Defining "clue" is outside the scope of this schema.
  """
  clues: [String]
}

enum QuestionType {
  tossup
  bonus
  lightning
}

"""
Docs group: Question
"""
type MatchQuestionBonus {
  """
  Information about the question used as a bonus.
  """
  question: Question

  """
  Information about each part of the bonus.
  """
  parts: [MatchQuestionBonusPart]!

  """
  The `MatchTeam`s who were eligible to answer this bonus. This is primarily useful for replacement questions. If omitted, it is assumed to be only the team who answered the tossup correctly (in scoring rules that do not use bouncebacks) or all teams (in scoring rules that use bouncebacks).
  """
  eligible_match_teams: [MatchTeam]
}

"""
For bonuses that do not have distinguishable parts — e.g. “Name any *m* of the *n* things that…” or 30–20–10-style bonuses, treat the entire bonus as a single `MatchQuestionBonusPart`.

Docs group: Question
"""
type MatchQuestionBonusPart {
  """
  Number of points earned by the controlling team. In all formats with which we are familiar, this must be a nonnegative integer.
  """
  controlled_points: Int!

  """
  Number of points earned by the non-controlling team. May be omitted if bonuses do not bounce back, but should not be omitted merely because the non-controlling team earned no points.

  In all formats with which we are familiar, this must be a nonnegative integer. Usually it can only be positive if `controlled_points` is `0`, but for bonuses of the form "Name any *m* of the *n*…") it would be possible for both `controlling_points` and `bounceback_points` to be positive.
  """
  bounceback_points: Int
}

"""
Docs group: Match
"""
type MatchTeam {
  """
  The team playing this side of the match.

  At least one of `team` or `card` is required.
  """
  team: Team

  """
  The card this team was holding at the beginning of this match.

  At least one of `team` or `card` is required.
  """
  card: String

  """
  Did this team forfeit this match? If absent, assumed to be `false`. Note that it is possible for both teams in a match to forfeit.
  """
  forfeit_loss: Boolean

  """
  The total score for this team in this match.

  It is invalid to provide both `points` and `bonus_points` since that could allow for inconsistent data. Generally, `bonus_points` is preferred; `points` is for results that do not include detailed (player-level) statistics.
  """
  points: Int

  """
  The number of points this team earned on bonuses.

  It is invalid to provide both `points` and `bonus_points` since that could allow for inconsistent data. Generally, `bonus_points` is preferred; `points` is for results that do not include detailed (player-level) statistics.
  """
  bonus_points: Int

  """
  The number of tossups this team answered correctly (in any form) without earning a bonus. If absent, assumed to be `0`. Generally this occurs in overtime, but some formats may use tossups without bonuses in one phase of the game. This field can be used to correctly calculate points per bonus, whose denominator in most formats would be the total number of tossups answered correctly by the team *minus* this field's value. For more complicated overtime scenarios (e.g. involving nonstandard `AnswerType`s), you will need to create different `AnswerType`s with different values of `awards_bonus`.
  """
  correct_tossups_without_bonuses: Int

  """
  The number of points this team earned on bonuses bounced back from the opponent.
  """
  bonus_bounceback_points: Int

  """
  The number of points this team earned on lightning questions.
  """
  lightning_points: Int

  """
  The number of points this team earned on lightning questions bounced back from the opponent.
  """
  lightning_bounceback_points: Int

  """
  The performances of the players on this team; see below.
  """
  match_players: [MatchPlayer]

  """
  Which players were playing when; see below.
  """
  lineups: [Lineup]

  """
  An object containing information that documents a team's acceptance of the result of the match. The absence of this object could mean the team has not yet accepted the result, the team has refused to accept the result, or simply that the tournament does not care to track acceptance of results. The exact meaning of "acceptance" is up to the tournament—it could mean acceptance of the overall outcome, acceptance of the final score, acceptance of every detail, or something else.
  """
  signature: Signature

  """
  Indicates that the match should be excluded from calculations of standings, statistics, etc. If absent, this will be assumed to be `false`.
  """
  suppress_from_statistics: Boolean
}

"""
Docs group: Match
"""
type Signature {
  """
  The URL of an image of the signature of a member of the team (typically a coach or captain), indicating their acceptance of the result.
  """
  image_url: String

  """
  Any comments the signer made related to acceptance of the result.
  """
  notes: String
}

"""
Docs group: Match
"""
type MatchPlayer {
  """
  The player whose performance in this match is being stored.
  """
  player: Player!

  """
  The number of tossups this player heard.
  """
  tossups_heard: Int!

  """
  The number of this player's answers for each answer value.
  """
  answer_counts: [PlayerAnswerCount]!
}

"""
Docs group: Match
"""
type PlayerAnswerCount {
  """
  Number of questions answered for this many points.
  """
  number: Int!

  """
  For nonstandard question types, the particular details about this answer type.
  """
  answer_type: AnswerType!
}

"""
Docs group: Match
"""
type Lineup {
  """
  Which question number this lineup heard first. The players in this lineup will be credited with hearing all tossups until another lineup takes precendence or until the end of the game, whichever comes first.
  """
  first_question: Int!

  """
  Which players were in this lineup, in the same order that they would appear on the scoresheet. This array's length is less than or equal to the `maximum_players_per_team` field from the tournament's `ScoringRules` object.
  """
  players: [Player]!

  """
  Which player serves as the captain during the time this `Lineup` is in effect. This player must be listed in the `players` field.
  """
  captain: Player

  """
  What opportunity the team had to set or change its lineup.

  If `reason` is "initial", then `first_question` should be `1`.

  The "segment_break" option represents a moment between portions of a match such as the end of the first quarter in a four-quarter format. "halftime" can be thought of as equivalent to "segment_break" for the common case of match formats whose regulation segments are simply two halves. "before_overtime" can be thought of as a special case of "segment_break".
  """
  reason: LineupReason!
}

enum LineupReason {
  initial
  own_timeout
  other_timeout
  halftime
  segment_break
  before_overtime
}

"""
A `Registration` object describes one school or other organization's entry into a tournament. It comprises the basic details about an organization and one or more `Team` objects.

It is expected that each `Registration` object represents a distinct school or other organization. For instance, if "Anywhere High School" enters two teams, there should not be two `Registration` objects whose `name` fields are `Anywhere A` and `Anywhere B` and one `Team` child each; there should be one `Registration` object whose `name` field is `Anywhere` (or `Anywhere High School`) and two `Team` children.

Docs group: Registration
"""
type Registration {
  id: ID!

  """
  The school or other organization's name.
  """
  name: String!

  """
  The location of this team's origin. This may be any combination of city, state, country, etc., as appropriate for the tournament, and should be in human-readable format.
  """
  location: String

  """
  The teams registered to play for this school or organization.
  """
  teams: [Team]!
}

"""
A `Team` has a team name, other entry-specific information about the team that may not apply to other teams from the same organization, a list of `Player` objects, and optionally, a list of `Rank` objects.

Docs group: Team
"""
type Team {
  id: ID!

  """
  The team's name.
  """
  name: String!

  """
  The players registered to play on this team.
  """
  players: [Player]

  """
  The ranks achieved by this team.
  """
  ranks: [Rank]
}

"""
Docs group: Team
"""
type Rank {
  """
  A `Ranking` for which the team is eligible.
  """
  ranking: Ranking!

  """
  The position/rank the team has achieved among all teams eligible for the given Ranking. Omitting this field indicates that the rank has not been determined yet (e.g. because the tournament is still in progress) but the team is eligible for the Ranking. May not be unique (i.e., there may be a tie).
  """
  position: Int
}

"""
A `Ranking` object describes an award that is given at a `Tournament`. A `Tournament` may have several `Ranking`s; for instance, it might have a "top small school" Ranking or a "top undergraduate team" Ranking.

Docs group: Team
"""
type Ranking {
  """
  The name of the ranking.
  """
  name: String

  """
  A description of the ranking, such as information on eligibility.
  """
  description: String
}

"""
A `Player` object has basic information about a player.

Docs group: Player
"""
type Player {
  id: ID!

  """
  The player's name.
  """
  name: String!

  """
  The player's year in school. Use `0` for kindergarten, `1` for first grade, &hellip;, `12` for twelfth grade (senior in high school), `13` for college frosh, &hellip;, `16` for college senior, `17` for college post-senior, and `18` for graduate student. Use `-1` when the notion of a grade is known to be inapplicable, e.g., for players who are not enrolled in school (this is distinct from omitting the field, which implies the player's year is unknown).
  """
  year: Int
}
